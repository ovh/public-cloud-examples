// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ovh

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-terraform-provider/sdks/go/ovh/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type MeInstallationTemplatePartitionSchemePartition struct {
	pulumi.CustomResourceState

	// Partition filesystem
	Filesystem pulumi.StringOutput `pulumi:"filesystem"`
	// partition mount point
	Mountpoint pulumi.StringOutput `pulumi:"mountpoint"`
	// step or order. specifies the creation order of the partition on the disk
	Order pulumi.Float64Output `pulumi:"order"`
	// raid partition type
	Raid pulumi.StringOutput `pulumi:"raid"`
	// name of this partitioning scheme
	SchemeName pulumi.StringOutput `pulumi:"schemeName"`
	// size of partition in MB, 0 => rest of the space
	Size pulumi.Float64Output `pulumi:"size"`
	// Template name
	TemplateName pulumi.StringOutput `pulumi:"templateName"`
	// partition type
	Type pulumi.StringOutput `pulumi:"type"`
	// The volume name needed for proxmox distribution
	VolumeName pulumi.StringOutput `pulumi:"volumeName"`
}

// NewMeInstallationTemplatePartitionSchemePartition registers a new resource with the given unique name, arguments, and options.
func NewMeInstallationTemplatePartitionSchemePartition(ctx *pulumi.Context,
	name string, args *MeInstallationTemplatePartitionSchemePartitionArgs, opts ...pulumi.ResourceOption) (*MeInstallationTemplatePartitionSchemePartition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Filesystem == nil {
		return nil, errors.New("invalid value for required argument 'Filesystem'")
	}
	if args.Mountpoint == nil {
		return nil, errors.New("invalid value for required argument 'Mountpoint'")
	}
	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	if args.SchemeName == nil {
		return nil, errors.New("invalid value for required argument 'SchemeName'")
	}
	if args.Size == nil {
		return nil, errors.New("invalid value for required argument 'Size'")
	}
	if args.TemplateName == nil {
		return nil, errors.New("invalid value for required argument 'TemplateName'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	ref, err := internal.PkgGetPackageRef(ctx)
	if err != nil {
		return nil, err
	}
	var resource MeInstallationTemplatePartitionSchemePartition
	err = ctx.RegisterPackageResource("ovh:index/meInstallationTemplatePartitionSchemePartition:MeInstallationTemplatePartitionSchemePartition", name, args, &resource, ref, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMeInstallationTemplatePartitionSchemePartition gets an existing MeInstallationTemplatePartitionSchemePartition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMeInstallationTemplatePartitionSchemePartition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MeInstallationTemplatePartitionSchemePartitionState, opts ...pulumi.ResourceOption) (*MeInstallationTemplatePartitionSchemePartition, error) {
	var resource MeInstallationTemplatePartitionSchemePartition
	ref, err := internal.PkgGetPackageRef(ctx)
	if err != nil {
		return nil, err
	}
	err = ctx.ReadPackageResource("ovh:index/meInstallationTemplatePartitionSchemePartition:MeInstallationTemplatePartitionSchemePartition", name, id, state, &resource, ref, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MeInstallationTemplatePartitionSchemePartition resources.
type meInstallationTemplatePartitionSchemePartitionState struct {
	// Partition filesystem
	Filesystem *string `pulumi:"filesystem"`
	// partition mount point
	Mountpoint *string `pulumi:"mountpoint"`
	// step or order. specifies the creation order of the partition on the disk
	Order *float64 `pulumi:"order"`
	// raid partition type
	Raid *string `pulumi:"raid"`
	// name of this partitioning scheme
	SchemeName *string `pulumi:"schemeName"`
	// size of partition in MB, 0 => rest of the space
	Size *float64 `pulumi:"size"`
	// Template name
	TemplateName *string `pulumi:"templateName"`
	// partition type
	Type *string `pulumi:"type"`
	// The volume name needed for proxmox distribution
	VolumeName *string `pulumi:"volumeName"`
}

type MeInstallationTemplatePartitionSchemePartitionState struct {
	// Partition filesystem
	Filesystem pulumi.StringPtrInput
	// partition mount point
	Mountpoint pulumi.StringPtrInput
	// step or order. specifies the creation order of the partition on the disk
	Order pulumi.Float64PtrInput
	// raid partition type
	Raid pulumi.StringPtrInput
	// name of this partitioning scheme
	SchemeName pulumi.StringPtrInput
	// size of partition in MB, 0 => rest of the space
	Size pulumi.Float64PtrInput
	// Template name
	TemplateName pulumi.StringPtrInput
	// partition type
	Type pulumi.StringPtrInput
	// The volume name needed for proxmox distribution
	VolumeName pulumi.StringPtrInput
}

func (MeInstallationTemplatePartitionSchemePartitionState) ElementType() reflect.Type {
	return reflect.TypeOf((*meInstallationTemplatePartitionSchemePartitionState)(nil)).Elem()
}

type meInstallationTemplatePartitionSchemePartitionArgs struct {
	// Partition filesystem
	Filesystem string `pulumi:"filesystem"`
	// partition mount point
	Mountpoint string `pulumi:"mountpoint"`
	// step or order. specifies the creation order of the partition on the disk
	Order float64 `pulumi:"order"`
	// raid partition type
	Raid *string `pulumi:"raid"`
	// name of this partitioning scheme
	SchemeName string `pulumi:"schemeName"`
	// size of partition in MB, 0 => rest of the space
	Size float64 `pulumi:"size"`
	// Template name
	TemplateName string `pulumi:"templateName"`
	// partition type
	Type string `pulumi:"type"`
	// The volume name needed for proxmox distribution
	VolumeName *string `pulumi:"volumeName"`
}

// The set of arguments for constructing a MeInstallationTemplatePartitionSchemePartition resource.
type MeInstallationTemplatePartitionSchemePartitionArgs struct {
	// Partition filesystem
	Filesystem pulumi.StringInput
	// partition mount point
	Mountpoint pulumi.StringInput
	// step or order. specifies the creation order of the partition on the disk
	Order pulumi.Float64Input
	// raid partition type
	Raid pulumi.StringPtrInput
	// name of this partitioning scheme
	SchemeName pulumi.StringInput
	// size of partition in MB, 0 => rest of the space
	Size pulumi.Float64Input
	// Template name
	TemplateName pulumi.StringInput
	// partition type
	Type pulumi.StringInput
	// The volume name needed for proxmox distribution
	VolumeName pulumi.StringPtrInput
}

func (MeInstallationTemplatePartitionSchemePartitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*meInstallationTemplatePartitionSchemePartitionArgs)(nil)).Elem()
}

type MeInstallationTemplatePartitionSchemePartitionInput interface {
	pulumi.Input

	ToMeInstallationTemplatePartitionSchemePartitionOutput() MeInstallationTemplatePartitionSchemePartitionOutput
	ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionOutput
}

func (*MeInstallationTemplatePartitionSchemePartition) ElementType() reflect.Type {
	return reflect.TypeOf((**MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (i *MeInstallationTemplatePartitionSchemePartition) ToMeInstallationTemplatePartitionSchemePartitionOutput() MeInstallationTemplatePartitionSchemePartitionOutput {
	return i.ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(context.Background())
}

func (i *MeInstallationTemplatePartitionSchemePartition) ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplatePartitionSchemePartitionOutput)
}

type MeInstallationTemplatePartitionSchemePartitionOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplatePartitionSchemePartitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (o MeInstallationTemplatePartitionSchemePartitionOutput) ToMeInstallationTemplatePartitionSchemePartitionOutput() MeInstallationTemplatePartitionSchemePartitionOutput {
	return o
}

func (o MeInstallationTemplatePartitionSchemePartitionOutput) ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionOutput {
	return o
}

// Partition filesystem
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Filesystem() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Filesystem }).(pulumi.StringOutput)
}

// partition mount point
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Mountpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Mountpoint }).(pulumi.StringOutput)
}

// step or order. specifies the creation order of the partition on the disk
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Order() pulumi.Float64Output {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.Float64Output { return v.Order }).(pulumi.Float64Output)
}

// raid partition type
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Raid() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Raid }).(pulumi.StringOutput)
}

// name of this partitioning scheme
func (o MeInstallationTemplatePartitionSchemePartitionOutput) SchemeName() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.SchemeName }).(pulumi.StringOutput)
}

// size of partition in MB, 0 => rest of the space
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.Float64Output { return v.Size }).(pulumi.Float64Output)
}

// Template name
func (o MeInstallationTemplatePartitionSchemePartitionOutput) TemplateName() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.TemplateName }).(pulumi.StringOutput)
}

// partition type
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The volume name needed for proxmox distribution
func (o MeInstallationTemplatePartitionSchemePartitionOutput) VolumeName() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.VolumeName }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplatePartitionSchemePartitionInput)(nil)).Elem(), &MeInstallationTemplatePartitionSchemePartition{})
	pulumi.RegisterOutputType(MeInstallationTemplatePartitionSchemePartitionOutput{})
}
